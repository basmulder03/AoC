using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace AoC.SourceGenerator;

[Generator]
public sealed class AoCRegistryGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // 1. Emit shared AoC infrastructure into every compilation that references the generator.
        AddAoCInfrastructure(context);

        // 2. Provide assembly name so we can derive the year from AoC.Y{year}.
        var assemblyNameProvider = context.CompilationProvider
            .Select(static (compilation, _) => compilation.AssemblyName ?? string.Empty);

        // 3. Discover all [AoCDay(x)] classes in the current compilation.
        var dayInfos = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                "AoC.SourceGenerator.AoCDayAttribute",
                static (node, _) => node is ClassDeclarationSyntax { AttributeLists.Count: > 0 },
                static (ctx, ct) => CreateDayInfo(ctx, ct)
            )
            .Where(static info => info.Day > 0 && !string.IsNullOrWhiteSpace(info.TypeName))
            .Collect(); // ImmutableArray<DayInfo>

        // 4. For assemblies that look like AoC.Y{year}, generate a year registry that wires all days.
        context.RegisterSourceOutput(
            dayInfos.Combine(assemblyNameProvider),
            static (spc, pair) =>
            {
                var (days, assemblyName) = pair;

                if (!TryGetYearFromAssemblyName(assemblyName, out var year))
                {
                    // Not an AoC.Y{year} assembly; nothing to do.
                    return;
                }

                if (days.IsDefaultOrEmpty)
                {
                    // No days in this project; nothing to generate.
                    return;
                }

                // Make sure we don't have duplicate day numbers; keep first occurrence per day.
                var distinctDays = days
                    .GroupBy(static d => d.Day)
                    .Select(static g => g.First())
                    .OrderBy(static d => d.Day)
                    .ToList();

                var source = GenerateYearRegistrySource(year, assemblyName, distinctDays);
                spc.AddSource($"AoCYear{year}Registry.g.cs", source);
            });
    }

    #region Infrastructure (attributes & interfaces)

    private static void AddAoCInfrastructure(IncrementalGeneratorInitializationContext context)
    {
        AddPostInitSource(
            context,
            "AoCYearAttribute.g.cs",
            """
            // <auto-generated/>
            using System;

            namespace AoC.SourceGenerator;

            [AttributeUsage(AttributeTargets.Class, AllowMultiple = false)]
            public sealed class AoCYearAttribute(int year) : Attribute
            {
                public int Year { get; } = year;
            }
            """
        );

        AddPostInitSource(
            context,
            "AoCDayAttribute.g.cs",
            """
            // <auto-generated/>
            using System;

            namespace AoC.SourceGenerator;

            [AttributeUsage(AttributeTargets.Class, AllowMultiple = false)]
            public sealed class AoCDayAttribute(int day) : Attribute
            {
                public int Day { get; } = day;
            }
            """
        );
    }

    private static void AddPostInitSource(
        IncrementalGeneratorInitializationContext context,
        string hintName,
        string source
    )
    {
        context.RegisterPostInitializationOutput(ctx => ctx.AddSource(hintName, source));
    }

    #endregion

    #region Discovery helpers

    private static (int Day, string TypeName) CreateDayInfo(
        GeneratorAttributeSyntaxContext context,
        CancellationToken _
    )
    {
        if (context.TargetSymbol is not INamedTypeSymbol typeSymbol)
        {
            return default;
        }

        var day = GetDayFromAttributes(context.Attributes);
        if (day <= 0)
        {
            return default;
        }

        // Fully qualified type name including global:: prefix, safe to use from anywhere.
        var typeName = typeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        return new ValueTuple<int, string>(day, typeName);
    }

    private static int GetDayFromAttributes(ImmutableArray<AttributeData> attributes)
    {
        foreach (
            var attribute in attributes
                .Where(attribute => attribute.AttributeClass?.ToDisplayString() == "AoC.SourceGenerator.AoCDayAttribute"
                )
            )
        {
            if (attribute.ConstructorArguments.Length > 0 &&
                attribute.ConstructorArguments[0].Value is int day &&
                day > 0)
            {
                return day;
            }
        }

        return 0;
    }

    private static bool TryGetYearFromAssemblyName(string assemblyName, out int year)
    {
        year = 0;
        if (string.IsNullOrWhiteSpace(assemblyName))
        {
            return false;
        }

        const string prefix = "AoC.Y";

        if (!assemblyName.StartsWith(prefix, StringComparison.OrdinalIgnoreCase))
        {
            return false;
        }

        var span = assemblyName.AsSpan(prefix.Length);
        return int.TryParse(span.ToString(), out year);
    }

    #endregion

    #region Year registry generation

    private static string GenerateYearRegistrySource(
        int year,
        string assemblyName,
        IReadOnlyList<(int Day, string TypeName)> days
    )
    {
        // Use assembly name as namespace (AoC.Y2024, etc.). Strip invalid characters just in case.
        var namespaceName = SanitizeNamespace(assemblyName);

        var daysEntries = string.Join("\n",
            days.Select(d => $"            [{d.Day}] = new {d.TypeName}(),"));

        var source = $$"""
                       // <auto-generated/>
                       #nullable enable
                       using System.Collections.Generic;
                       using AoC.Tool.Interfaces;

                       namespace {{namespaceName}};

                       [AoCYear({{year}})]
                       public sealed class AoCYear{{year}}Registry : IAoCYearRegistry
                       {
                           public int Year => {{year}};

                           public IReadOnlyDictionary<int, IAoCDay> Days { get; } =
                               new Dictionary<int, IAoCDay>
                               {
                       {{daysEntries}}
                               };

                           public bool TryGetDay(int day, out IAoCDay? dayInstance)
                               => Days.TryGetValue(day, out dayInstance);
                       }
                       #nullable disable
                       """;

        return source;

    }

    private static string SanitizeNamespace(string raw)
    {
        if (string.IsNullOrWhiteSpace(raw))
        {
            return "AoCGenerated";
        }

        // Very simple sanitize: replace characters that are not letter, digit, or dot.
        var chars = raw.ToCharArray();
        for (var i = 0; i < chars.Length; i++)
        {
            var c = chars[i];
            if (!(char.IsLetterOrDigit(c) || c == '.'))
            {
                chars[i] = '_';
            }
        }

        return new string(chars);
    }

    #endregion
}
