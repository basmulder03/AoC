using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace AoC.SourceGenerator;

[Generator]
public class AoCYearRegistryGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var dayClasses = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                "AoC.Core.AoCDayAttribute",
                static (node, _) => node is ClassDeclarationSyntax,
                static (ctx, _) => ctx
            )
            .Collect();

        var compilationAndClasses = context.CompilationProvider.Combine(dayClasses);
        
        context.RegisterSourceOutput(compilationAndClasses, static (spc, source) =>
        {
            var (compilation, classSymbols) = source;

            var entriesByYear = new Dictionary<int, List<(int day, string fqName)>>();

            foreach (var c in classSymbols)
            {
                if (c.TargetSymbol is not INamedTypeSymbol type ||
                    !type.AllInterfaces.Any(i => i.ToDisplayString() == "AoC.Core.IAoCDay"))
                {
                    continue;
                }
                
                var attr = type.GetAttributes()
                    .FirstOrDefault(a => a.AttributeClass?.ToDisplayString() == "AoC.Core.AoCDayAttribute");

                if (attr is null)
                {
                    continue;
                }
                
                var year = (int)attr.ConstructorArguments[0].Value!;
                var day = (int)attr.ConstructorArguments[1].Value!;
                
                if (!entriesByYear.TryGetValue(year, out var yearEntries))
                {
                    yearEntries = new List<(int, string)>();
                    entriesByYear[year] = yearEntries;
                }
                
                yearEntries.Add((day, type.ToDisplayString()));
            }

            // Generate a registry class for this assembly if it contains any days
            if (entriesByYear.Count > 0)
            {
                // Assuming each project contains days for only one year
                var year = entriesByYear.Keys.First();
                var entries = entriesByYear[year];
                var assemblyName = compilation.AssemblyName ?? "UnknownAssembly";
                var namespaceName = GetNamespaceForAssembly(assemblyName);
                
                var sourceText = GenerateYearRegistry(year, entries, namespaceName);
                spc.AddSource($"AoC{year}Registry.g.cs", sourceText);
                
                // Generate assembly attribute to register this year registry
                var assemblyAttrSource = GenerateAssemblyAttribute(year, namespaceName);
                spc.AddSource($"AssemblyInfo.AoC{year}.g.cs", assemblyAttrSource);
            }
        });
    }

    private static string GetNamespaceForAssembly(string assemblyName)
    {
        // Convert assembly name like "AoC.Y2025" to namespace
        return assemblyName.Replace('.', '.');
    }

    private static string GenerateYearRegistry(int year, List<(int day, string fqName)> entries, string namespaceName)
    {
        var sb = new StringBuilder();
        sb.AppendLine("/// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("using AoC.Core;");
        sb.AppendLine();
        sb.AppendLine($"namespace {namespaceName};");
        sb.AppendLine();
        sb.AppendLine($"public sealed class AoC{year}Registry : IAoCYearRegistry");
        sb.AppendLine("{");
        sb.AppendLine($"    public int Year => {year};");
        sb.AppendLine("    ");
        sb.AppendLine("    private static readonly Dictionary<int, IAoCDay> _days = new()");
        sb.AppendLine("    {");
        
        foreach (var (day, fqName) in entries.OrderBy(e => e.day))
        {
            sb.AppendLine($"        [{day}] = new {fqName}(),");
        }

        sb.AppendLine("    };");
        sb.AppendLine();
        sb.AppendLine("    public IReadOnlyDictionary<int, IAoCDay> Days => _days;");
        sb.AppendLine();
        sb.AppendLine("    public bool TryGetDay(int day, out IAoCDay? dayInstance)");
        sb.AppendLine("    {");
        sb.AppendLine("        return _days.TryGetValue(day, out dayInstance);");
        sb.AppendLine("    }");
        sb.AppendLine("}");

        return sb.ToString();
    }

    private static string GenerateAssemblyAttribute(int year, string namespaceName)
    {
        return $"/// <auto-generated/>\n" +
               $"using AoC.Core;\n\n" +
               $"[assembly: AoCYearRegistry({year}, typeof({namespaceName}.AoC{year}Registry))]";
    }
}


